1、dyld 的加载顺序
整体的过程：
配置环境变量 -> 加载共享缓存 -> 实例化主程序 -> 加载动态库 -> 链接动态库 就已经完成了

动态库分为两种：
1、系统的共享缓存库（UIKit / Foundation）
2、app 自己的动态库（embed）
a.加载系统的共享缓存库
dyld shared cache

动态库链接
懒加载符号表

第一次调用
stub 桩 =》懒加载符号表=》stub——help=》绑定
第二次调用
stub 桩 =》懒加载符号表

编译时：放在懒加载符号表
运行时通过 stub 去绑定

动态库加载流程：
\_dyld_star =>dyldboostrap::start=>

动态库的加载顺序是根据 xcode 中的 build phases 中的 link binary 顺序来加载的
使用 cocoapods 的时候 pods 会按照字母进行排序

dyld 过程
1 设置运行环境:这一步主要是设置运行参数、环境变量等。
2 加载共享缓存:将默认的库加载到进程中。
3 实例化主程序:判断 Mach-O 文件的兼容性，如果兼容性满足,这一步将主程序的 Mach-O 加载进内存，并实例化一个 ImageLoader。
4 加载插入的动态库:这一步是加载环境变量 DYLD_INSERT_LIBRARIES 中配置的动态库
5 链接主程序:

1. 根据 LC_LOAD_DYLIB 加载命令把所有依赖库加载进内存。
2. 递归刷新依赖库的层级。 3.由于 ASLR 的存在，必须递归对主程序以及依赖库进行重定位操作。 4.把主程序二进制和依赖进来的动态库全部执行符号表绑定。 5.如果链接的不是主程序二进制的话，会在此时执行弱符号绑定，主程序二进制则在 link()完后再执行
   6 弱符号绑定，后面会进行分析。
   7 链接插入的动态库:这一步与链接主程序一样，将前面调用 addImage()函数保存在 sAllImages 中的动态库列表循环取出并调用 link()进行链接。
   8 执行弱符号绑定
   9 执行初始化方法
   10 查找入口点并返回


动态库的加载顺序和+load的执行顺序

如果没有依赖关系 按照 xcode的link binary顺序执行
如果有依赖关系 按照递归的调用实现

+load  c++的方法